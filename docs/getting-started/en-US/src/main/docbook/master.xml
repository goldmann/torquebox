<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % images_ent SYSTEM "images.ent"> 
  %images_ent;
] >
<book lang="en">
  <bookinfo>
    <title>TorqueBox Getting Started Guide</title>

    <releaseinfo>${project.version}</releaseinfo>

    <authorgroup>
      <corpauthor>The TorqueBox Project</corpauthor>
    </authorgroup>
  </bookinfo>

  <toc></toc>

  <chapter id="first-steps">
    <title>First Steps</title>

    <para>
      Choose the section below to follow based on your development
      environment - Windows users should follow <xref
      linkend="first-steps-windows"/>, RVM users should follow <xref
      linkend="first-steps-rvm"/>, and regular Mac or Linux users
      should follow <xref linkend="first-steps-mac-linux"/>.
    </para>

    <section id="first-steps-mac-linux">
      <title>First Steps on Mac / Linux</title>

      <para>
        If you use Ruby Version Manager (RVM), be sure to follow the
        <xref linkend="first-steps-rvm"/> instructions and not the
        generic Mac / Linux instructions.
       </para>

       <section>
        <title>Your First Rails Application</title>

        <para>
          Ensure you have Java 6 or above installed then download and
          extract the TorqueBox binary distribution and set a few
          environment variables.

           <screen><prompt>$</prompt> <command>wget http://torquebox.org/release/org/torquebox/torquebox-dist/${project.version}/torquebox-dist-${project.version}-bin.zip</command>
...
2012-09-13 09:35:56 (1.61 MB/s) - `torquebox-dist-${project.version}-bin.zip' saved [152039457/152039457]

<prompt>$</prompt> <command>unzip torquebox-dist-${project.version}-bin.zip -d ~ </command>
...
  inflating: torquebox-${project.version}/Rakefile
<prompt>$</prompt> <command>export TORQUEBOX_HOME=~/torquebox-${project.version}</command>
<prompt>$</prompt> <command>export JBOSS_HOME=$TORQUEBOX_HOME/jboss</command>
<prompt>$</prompt> <command>export JRUBY_HOME=$TORQUEBOX_HOME/jruby</command>
<prompt>$</prompt> <command>export PATH=$JRUBY_HOME/bin:$PATH</command></screen>

          You'll likely want to place the exports somewhere that gets
          loaded automatically - <filename>~/.bashrc</filename>,
          <filename>~/.bash_profile</filename>, or wherever your
          operating system suggests placing user-specific environment
          variables.
        </para>

        <para>
          Install Rails and create a new Rails example application.

          <screen><prompt>$</prompt> <command>mkdir -p ~/torquebox_examples/rails_example</command>
<prompt>$</prompt> <command>cd ~/torquebox_examples/rails_example</command>
<prompt>$</prompt> <command>gem install rails</command>
...
Successfully installed rails-3.2.9
27 gems installed
<prompt>$</prompt> <command>rails new .</command>
...
Using rails (3.2.9) 
Installing sass (3.2.3) 
Installing sass-rails (3.2.5) 
Installing therubyrhino_jar (1.7.4) 
Installing therubyrhino (2.0.2) 
Installing uglifier (1.3.0) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.</screen>
          <note>
            <title>Bundler and jruby-openssl</title>
            <para>
              Some versions of JRuby, Bundler, and jruby-openssl don't
              play well together so if you get an error when Rails
              tries to run <command>bundle install</command> regarding
              jruby-openssl, edit the <filename>Gemfile</filename> to
              change the source line from https to http and manually
              run <command>bundle install</command> afterwards.
            </para>
          </note>
        </para>

        <para>
          Add a simple scaffolded resource, deploy it to TorqueBox,
          and run TorqueBox.

          <screen><prompt>$</prompt> <command>rails g scaffold post title body:text</command>
...
      create      app/assets/stylesheets/posts.css.scss
      invoke  scss
      create      app/assets/stylesheets/scaffolds.css.scss
<prompt>$</prompt> <command>rake db:migrate</command>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0060s
   -> 0 rows
==  CreatePosts: migrated (0.0080s) ===========================================

<prompt>$</prompt> <command>torquebox deploy</command>
Deployed: rails_example-knob.yml
    into: /Users/someone/torquebox-${project.version}/jboss/standalone/deployments
<prompt>$</prompt> <command>torquebox run </command>
...
15:59:28,053 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 2) JBAS018559: Deployed "rails_example-knob.yml"</screen>
        </para>

        <para>
          Open <ulink url="http://localhost:8080"/> in your browser
          and you'll be greeted with the Rails "Welcome aboard"
          page. Navigate to <ulink
          url="http://localhost:8080/posts/"/> to see your scaffolded
          resource.
        </para>

        <para>
          Now edit
          <filename>~/torquebox_examples/rails_example/app/views/posts/index.html.erb</filename>
          then refresh the posts page in your browser and see your
          changes. Changes to your Rails application show up
          immediately in the browser, as expected. When you're done,
          press CTRL+C in the terminal to stop TorqueBox before
          continuing with the next steps.
        </para>
      </section>

      <section>
        <title>Subsequent Applications</title>

        <para>
          Deploying multiple applications to TorqueBox is
          straightforward, but let's walk through the required steps.
          We'll create a Rack application to go with our Rails example
          application created earlier. If TorqueBox is still running
          stop it with CTRL+C in its terminal window before following
          the steps below.

      <screen><prompt>$</prompt> <command>mkdir -p ~/torquebox_examples/rack_example</command>
<prompt>$</prompt> <command>cd ~/torquebox_examples/rack_example</command>
<prompt>$</prompt> <command>gem install rack</command>
Fetching: rack-1.4.1.gem (100%)
Successfully installed rack-1.4.1
1 gem installed
</screen>

          Now create a <filename>config.ru</filename> for our example
          rack application.
          <example>
            <title><filename>~/torquebox_examples/rack_example/config.ru</filename></title>
            <programlisting>app = lambda { |env|
  [200, { 'Content-Type' => 'text/html' }, "Hello from Rack\n" ]
}
run app</programlisting>
          </example>

          Deploy the Rack application at a context-path of "/rack"
          since we already have the Rails application deployed at the
          root context.

        <screen><prompt>$</prompt> <command>torquebox deploy --context-path=/rack</command>
Deployed: rack_example-knob.yml
    into: /Users/someone/torquebox-${project.version}/jboss/standalone/deployments</screen>
        </para>

        <para>
          Now you should be able to run TorqueBox and see both
          applications deployed.

        <screen><prompt>$</prompt> <command>torquebox run</command>
...
19:25:38,049 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "rails_example-knob.yml"
19:25:38,050 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "rack_example-knob.yml"</screen>

          Visit <ulink url="http://localhost:8080"/> and <ulink
          url="http://localhost:8080/rack/"/> to see that both your
          Rails and Rack applications are deployed and working.
        </para>

        <para>
          Congratulations! You now know all the basics to proceed with
          the rest of this getting started guide when using a Mac or
          Linux.
        </para>

        <para>Continue to <xref linkend="adding-torquebox-features"/>.</para>
      </section>
     </section>

    <section id="first-steps-windows">
      <title>First Steps on Windows</title>

      <section>
        <title>Your First Rails Application</title>

        <para>
          Ensure you have Java 6 or above installed then download
          TorqueBox using your web browser from <ulink
          url="http://torquebox.org/release/org/torquebox/torquebox-dist/${project.version}/torquebox-dist-${project.version}-bin.zip"/>. Right-click
          the downloaded zip in Windows Explorer and select Extract
          All. When prompted for a folder to extract the files to,
          choose your user's home directory (ie
          <filename>C:\Users\someone\</filename>).
        </para>

        <para>
          After TorqueBox is extracted, we need to set a few
          environment variables. Find the Advanced System Settings
          dialog (in Windows 7 this is Control Panel -> System and
          Security -> System -> Advanced System Settings) and click
          the Environment Variables button. We want to add three new
          user environment variables. Add
          <varname>TORQUEBOX_HOME</varname> with a value of
          <filename>%HOME%\torquebox-${project.version}</filename>. Add
          <varname>JBOSS_HOME</varname> with a value of
          <filename>%HOME%\torquebox-${project.version}\jboss</filename>. Add
          <varname>JRUBY_HOME</varname> with a value of
          <filename>%HOME%\torquebox-${project.version}\jruby</filename>. Also modify the
          <varname>Path</varname> environment variable by prepending
          <filename>%JRUBY_HOME%\bin;</filename> to the front of the
          current value. Click the OK button to save and close the
          Environment Variables dialog.
        </para>

        <para>
          Now let's open up a Command Prompt to install Rails and
          create a new Rails example application. You can open a
          Command Prompt by clicking the Windows button in the bottom
          left and typing <filename>cmd</filename> in the search box.

          <screen><prompt>&gt;</prompt> <command>mkdir %HOME%\torquebox_examples\rails_example</command>
<prompt>&gt;</prompt> <command>cd %HOME%\torquebox_examples\rails_example</command>
<prompt>&gt;</prompt> <command>gem install rails</command>
...
Successfully installed rails-3.2.9
27 gems installed
<prompt>&gt;</prompt> <command>rails new .</command>
...
Using rails (3.2.9) 
Installing sass (3.2.5) 
Installing sass-rails (3.2.5) 
Installing therubyrhino_jar (1.7.4) 
Installing therubyrhino (2.0.2) 
Installing uglifier (1.3.0) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.</screen>
          <note>
            <title>Bundler and jruby-openssl</title>
            <para>
              Some versions of JRuby, Bundler, and jruby-openssl don't
              play well together so if you get an error when Rails
              tries to run <command>bundle install</command> regarding
              jruby-openssl, edit the <filename>Gemfile</filename> to
              change the source line from https to http and manually
              run <command>bundle install</command> afterwards.
            </para>
          </note>
        </para>

        <para>
          Add a simple scaffolded resource, deploy it to TorqueBox,
          and run TorqueBox.

          <screen><prompt>&gt;</prompt> <command>rails g scaffold post title body:text</command>
...
      create      app/assets/stylesheets/posts.css.scss
      invoke  scss
      create      app/assets/stylesheets/scaffolds.css.scss
<prompt>&gt;</prompt> <command>rake db:migrate</command>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0060s
   -> 0 rows
==  CreatePosts: migrated (0.0080s) ===========================================

<prompt>&gt;</prompt> <command>torquebox deploy</command>
Deployed: rails_example-knob.yml
    into: C:\Users\someone\torquebox-${project.version}\jboss\standalone\deployments
<prompt>&gt;</prompt> <command>echo Y | jruby -S torquebox run </command>
...
15:59:28,053 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 2) JBAS018559: Deployed "rails_example-knob.yml"</screen>

          <tip>
            <title>Why <command>echo Y</command> and <command>jruby -S</command>?</title>
            <para>
              When stopping TorqueBox via CTRL+C, the Windows Command
              Prompt will ask you if you want to "Terminate batch job
              (Y/N)?". Piping <command>echo Y</command> into the
              command just prevents you from having to answer this
              prompt.

              We prefix the command with <command>jruby -S</command>
              because if we just used <command>echo Y | torquebox
              run</command> there's currently a bug where TorqueBox
              would get stuck in an infinite restart loop upon
              stopping.
            </para>
          </tip>
        </para>

        <para>
          Open <ulink url="http://localhost:8080"/> in your browser
          and you'll be greeted with the Rails "Welcome aboard"
          page. Navigate to <ulink
          url="http://localhost:8080/posts/"/> to see your scaffolded
          resource.
        </para>

        <para>
          Now edit
          <filename>%HOME%\torquebox_examples\rails_example\app\views\posts\index.html.erb</filename>
          then refresh the posts page in your browser and see your
          changes. Changes to your Rails application show up
          immediately in the browser, as expected. When you're done,
          press CTRL+C in the terminal to stop TorqueBox before
          continuing with the next steps.
        </para>
      </section>

      <section>
        <title>Subsequent Applications</title>

        <para>
          Deploying multiple applications to TorqueBox is
          straightforward, but let's walk through the required steps.
          We'll create a Rack application to go with our Rails example
          application created earlier. If TorqueBox is still running
          stop it with CTRL+C in its terminal window before following
          the steps below.

      <screen><prompt>&gt;</prompt> <command>mkdir %HOME%\torquebox_examples\rack_example</command>
<prompt>&gt;</prompt> <command>cd %HOME%\torquebox_examples\rack_example</command>
<prompt>&gt;</prompt> <command>gem install rack</command>
Fetching: rack-1.4.1.gem (100%)
Successfully installed rack-1.4.1
1 gem installed
</screen>

          Now create a <filename>config.ru</filename> for our example
          rack application.
          <example>
            <title><filename>%HOME%\torquebox_examples\rack_example\config.ru</filename></title>
            <programlisting>app = lambda { |env|
  [200, { 'Content-Type' => 'text/html' }, "Hello from Rack\n" ]
}
run app</programlisting>
          </example>

          Deploy the Rack application at a context-path of "/rack"
          since we already have the Rails application deployed at the
          root context.

        <screen><prompt>&gt;</prompt> <command>torquebox deploy --context-path=/rack</command>
Deployed: rack_example-knob.yml
    into: C:\Users\someone\torquebox-${project.version}\jboss\standalone\deployments</screen>
        </para>

        <para>
          Now you should be able to run TorqueBox and see both
          applications deployed.

        <screen><prompt>&gt;</prompt> <command>echo Y | jruby -S torquebox run</command>
...
19:25:38,049 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "rails_example-knob.yml"
19:25:38,050 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "rack_example-knob.yml"</screen>

          Visit <ulink url="http://localhost:8080"/> and <ulink
          url="http://localhost:8080/rack/"/> to see that both your
          Rails and Rack applications are deployed and working.
        </para>

        <para>
          Congratulations! You now know all the basics to proceed with
          the rest of this getting started guide when using
          Windows. The filesystem paths and command prompts shown in
          future chapters won't be Windows-specific, so be sure to
          translate any paths to the appropriate format before
          executing the example commands.
        </para>

        <para>Continue to <xref linkend="adding-torquebox-features"/>.</para>

      </section>

    </section>

    <section id="first-steps-rvm">
      <title>First Steps with RVM</title>

      <section>
        <title>Your First Rails Application</title>

        <para>
          Ensure you have a recent JRuby installed then install the
          <varname>torquebox-server</varname> gem into the global
          gemset.

        <screen><prompt>$</prompt> <command>rvm install jruby-${version.jruby}</command>
<prompt>$</prompt> <command>rvm use jruby-${version.jruby}@global</command>
<prompt>$</prompt> <command>gem install torquebox-server</command></screen>
        </para>

        <para>
          Create a directory and project-specific gemset for our
          example application.

        <screen><prompt>$</prompt> <command>mkdir -p ~/torquebox_examples/rails_example</command>
<prompt>$</prompt> <command>cd ~/torquebox_examples/rails_example</command>
<prompt>$</prompt> <command>rvm --rvmrc --create jruby-${version.jruby}@tb_rails_example</command></screen>
        </para>

        <para>
          Change to the Rails example directory, trust the generated
          .rvmrc file when prompted, and install Rails.

        <screen><prompt>$</prompt> <command>cd ~/torquebox_examples/rails_example</command>
====================================================================================
= NOTICE                                                                           =
====================================================================================
= RVM has encountered a new or modified .rvmrc file in the current directory       =
= This is a shell script and therefore may contain any shell commands.             =
=                                                                                  =
= Examine the contents of this file carefully to be sure the contents are          =
= safe before trusting it! ( Choose v[iew] below to view the contents )            =
====================================================================================
Do you wish to trust this .rvmrc file? (/Users/someone/torquebox_examples/rails_example/.rvmrc)
y[es], n[o], v[iew], c[ancel]> y
<prompt>$</prompt> <command>rvm gemset list</command>

gemsets for jruby-${version.jruby} (found in /Users/someone/.rvm/gems/jruby-${version.jruby})
   global
=> tb_rails_example

<prompt>$</prompt> <command>gem install rails</command>
...
Successfully installed rails-3.2.9
27 gems installed</screen>
        </para>

        <para>
          Create a new Rails application, add a simple scaffolded
          resource, deploy it to TorqueBox, and run TorqueBox.

        <screen><prompt>$</prompt> <command>rails new .</command>
...
Using rails (3.2.9) 
Installing sass (3.2.5) 
Installing sass-rails (3.2.5) 
Installing therubyrhino_jar (1.7.4) 
Installing therubyrhino (2.0.2) 
Installing uglifier (1.3.0) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
<prompt>$</prompt> <command>rails g scaffold post title body:text</command>
...
      create      app/assets/stylesheets/posts.css.scss
      invoke  scss
      create      app/assets/stylesheets/scaffolds.css.scss
<prompt>$</prompt> <command>rake db:migrate</command>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0060s
   -> 0 rows
==  CreatePosts: migrated (0.0080s) ===========================================

<prompt>$</prompt> <command>torquebox deploy</command>
Deployed: rails_example-knob.yml
    into: /Users/someone/.rvm/gems/jruby-${version.jruby}@global/gems/torquebox-server-${project.version}-java/jboss/standalone/deployments
<prompt>$</prompt> <command>torquebox run </command>
...
15:59:28,053 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 2) JBAS018559: Deployed "rails_example-knob.yml"</screen>
        </para>

        <para>
          Open <ulink url="http://localhost:8080"/> in your browser
          and you'll be greeted with the Rails "Welcome aboard"
          page. Navigate to <ulink
          url="http://localhost:8080/posts/"/> to see your scaffolded
          resource.
        </para>

        <para>
          Now edit
          <filename>~/torquebox_examples/rails_example/app/views/posts/index.html.erb</filename>
          then refresh the posts page in your browser and see your
          changes. Changes to your Rails application show up
          immediately in the browser, as expected. When you're done,
          press CTRL+C in the terminal to stop TorqueBox before
          continuing with the next steps.
        </para>

        <para>
          When you want to take advantage of TorqueBox-specific
          features, like we'll do in subsequent chapters, you'll need
          the <varname>torquebox</varname> gem in your application's
          Gemfile. However, since we're using
          <varname>torquebox-server</varname> under RVM to install
          TorqueBox, you'll want to ensure this gem is in the Gemfile
          for every application as well. If it's not you'll receive
          errors trying to use the <command>torquebox</command>
          because bundler will be unable to find the
          <varname>torquebox-server</varname> gem.

          <example>
            <title><filename>~/torquebox_examples/rails_example/Gemfile</filename></title>
            <programlisting>source 'https://rubygems.org'

gem 'rails', '3.2.9'

gem 'activerecord-jdbcsqlite3-adapter'
gem 'jruby-openssl'
gem 'json'

group :assets do
  gem 'sass-rails',   '~> 3.2.3'
  gem 'coffee-rails', '~> 3.2.1'
  gem 'therubyrhino'
  gem 'uglifier', '>= 1.0.3'
end

gem 'jquery-rails'

gem 'torquebox', '~> ${project.version}'
gem 'torquebox-server', '~> ${project.version}'</programlisting>
          </example>
        </para>

      </section>

      <section>
        <title>Subsequent Applications</title>

        <para>
          Deploying multiple applications to TorqueBox when using RVM
          and project-specific gemsets requires a small amount of
          extra work. To walk through the required steps, let's create
          a second Rack application to go with our Rails example
          application created earlier. If TorqueBox is still running
          stop it with CTRL+C in its terminal window before following
          the steps below.

      <screen><prompt>$</prompt> <command>mkdir -p ~/torquebox_examples/rack_example</command>
<prompt>$</prompt> <command>cd ~/torquebox_examples/rack_example</command>
<prompt>$</prompt> <command>rvm --rvmrc --create jruby-${version.jruby}@tb_rack_example</command>
<prompt>$</prompt> <command>cd ~/torquebox_examples/rack_example</command>
====================================================================================
= NOTICE                                                                           =
====================================================================================
= RVM has encountered a new or modified .rvmrc file in the current directory       =
= This is a shell script and therefore may contain any shell commands.             =
=                                                                                  =
= Examine the contents of this file carefully to be sure the contents are          =
= safe before trusting it! ( Choose v[iew] below to view the contents )            =
====================================================================================
Do you wish to trust this .rvmrc file? (/Users/someone/torquebox_examples/rack_example/.rvmrc)
y[es], n[o], v[iew], c[ancel]> y
<prompt>$</prompt> <command>rvm gemset list</command>

gemsets for jruby-${version.jruby} (found in /Users/someone/.rvm/gems/jruby-${version.jruby})
   global
=> tb_rack_example
   tb_rails_example

<prompt>$</prompt> <command>gem install rack</command>
Fetching: rack-1.4.1.gem (100%)
Successfully installed rack-1.4.1
1 gem installed
</screen>

          Now create a <filename>config.ru</filename> for our example
          rack application.
          <example>
            <title><filename>~/torquebox_examples/rack_example/config.ru</filename></title>
            <programlisting>app = lambda { |env|
  [200, { 'Content-Type' => 'text/html' }, "Hello from Rack\n" ]
}
run app</programlisting>
          </example>

          Deploy the Rack application at a context-path of "/rack"
          since we already have the Rails application deployed at the
          root context.

        <screen><prompt>$</prompt> <command>torquebox deploy --context-path=/rack</command>
Deployed: rack_example-knob.yml
    into: /Users/someone/.rvm/gems/jruby-${version.jruby}@global/gems/torquebox-server-${project.version}-java/jboss/standalone/deployments</screen>
        </para>

        <para>
          Now that two applications are deployed to TorqueBox, each
          with separate RVM gemsets, we hit an issue that trips up
          most users of RVM and TorqueBox. TorqueBox runs as a single
          process but RVM is really designed to have a separate
          process per project for gemsets to work out of the box. We
          can work around this by emulating the environment variables
          RVM sets when reading our <filename>.rvmrc</filename> in a
          <filename>torquebox.rb</filename> file for each application.

          <example>
            <title><filename>~/torquebox_examples/rack_example/torquebox.rb</filename></title>
            <programlisting>TorqueBox.configure do
  environment do
    GEM_HOME "#{ENV['rvm_path']}/gems/jruby-${version.jruby}@tb_rack_example"
    GEM_PATH "#{ENV['rvm_path']}/gems/jruby-${version.jruby}@tb_rack_example:#{ENV['rvm_path']}/gems/jruby-${version.jruby}@global"
  end
end</programlisting>
          </example>

          <example>
            <title><filename>~/torquebox_examples/rails_example/config/torquebox.rb</filename></title>
            <programlisting>TorqueBox.configure do
  environment do
    GEM_HOME "#{ENV['rvm_path']}/gems/jruby-${version.jruby}@tb_rails_example"
    GEM_PATH "#{ENV['rvm_path']}/gems/jruby-${version.jruby}@tb_rails_example:#{ENV['rvm_path']}/gems/jruby-${version.jruby}@global"
  end
end</programlisting>
          </example>

          Now you should be able to run TorqueBox and see both
          applications deployed.

        <screen><prompt>$</prompt> <command>torquebox run</command>
...
19:25:38,049 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "rails_example-knob.yml"
19:25:38,050 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "rack_example-knob.yml"</screen>

          Visit <ulink url="http://localhost:8080"/> and <ulink
          url="http://localhost:8080/rack/"/> to see that both your
          Rails and Rack applications are deployed and working.
        </para>

        <para>
          Congratulations! You now know all the basics to proceed with
          the rest of this getting started guide when using RVM. The
          most important thing to remember is to add the
          <filename>torquebox.rb</filename> that sets the
          <varname>GEM_HOME</varname> and <varname>GEM_PATH</varname>
          environment variables for each application that uses a
          project-specific gemset.
        </para>

        <para>Continue to <xref linkend="adding-torquebox-features"/>.</para>
      </section>
    </section>

   </chapter>

  <chapter id="adding-torquebox-features">
    <title>Adding TorqueBox Features</title>

    <para>
      This chapter builds upon the simple Rails application we created
      in <xref linkend="first-steps"/> by modifying it to take
      advantage of TorqueBox features.
    </para>

    <section id="features-rails-template">
      <title>TorqueBox Rails Template</title>

      <para>
        TorqueBox ships with a Rails template that we can use to
        automatically add <filename>torquebox</filename> to the
        Gemfile, convert the session store to the optional TorqueBox
        clustered session storage, setup all ActiveRecord objects to
        have <classname>TorqueBox::Backgroundable</classname> methods
        available, and add some TorqueBox-specific Rake tasks.

        <screen><prompt>$</prompt> <command>cd ~/torquebox_examples/rails_example</command>
<prompt>$</prompt> <command>torquebox rails</command>
       apply  /Users/someone/torquebox-${project.version}/share/rails/template.rb
     gemfile    torquebox (${project.version})
      remove    config/initializers/session_store.rb
 initializer    session_store.rb
 initializer    active_record_backgroundable.rb
    rakefile    torquebox.rake</screen>
      </para>
    </section>

    <section id="features-backgroundable">
      <title>Running Tasks in the Background</title>

      <para>
        To illustrate how TorqueBox makes it effortless to run
        long-running tasks in the background, let's first add a
        long-running task to our <classname>Post</classname>
        model. After each <classname>Post</classname> is created, lets
        publish a message to our favorite social network linking to
        that post. For simplicitly we'll just log a message and sleep
        for a few seconds to simulate the publish.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/models/post.rb</filename></title>
          <programlisting><![CDATA[class Post < ActiveRecord::Base
  attr_accessible :body, :title

  after_create :publish_to_social_network

  def publish_to_social_network
    puts "Publishing '#{title}' to our favorite social network"
    sleep(5)
    puts "Post published"
  end
end]]></programlisting>
        </example>

        Start TorqueBox if it isn't already running via
        <command>torquebox run</command> (Windows users remember to
        use <command>echo Y | jruby -S torquebox run</command>),
        navigate to <ulink url="http://localhost:8080/posts/"/>,
        create a new post, and observe the output from the TorqueBox
        console.

        <screen>09:11:19,746 INFO  [stdout] (http-localhost/127.0.0.1:8080-1) Publishing 'Chunky Bacon Fever' to our favorite social network
09:11:24,747 INFO  [stdout] (http-localhost/127.0.0.1:8080-1) Post published</screen>

        As you can see, it took 5 seconds to publish the post and
        during that five seconds the browser was waiting on a response
        from the server. There's no reason the browser needs to wait
        until the post is published, so let's see how easy it is to
        convert the publish_to_social_network method to run in the
        background.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/models/post.rb</filename></title>
          <programlisting><![CDATA[class Post < ActiveRecord::Base
  attr_accessible :body, :title

  after_create :publish_to_social_network
  always_background :publish_to_social_network

  def publish_to_social_network
    puts "Publishing '#{title}' to our favorite social network"
    sleep(5)
    puts "Post published"
  end
end]]></programlisting>
        </example>

        Create a new post and you'll see that the browser returns
        immediately and in the TorqueBox console the messaging runtime
        will spin up (since
        <classname>TorqueBox::Backgroundable</classname> uses
        messaging and the first message we send starts the messaging
        runtime pool) and publish the post to our favorite social
        network in the background.
      </para>
    </section>

    <section id="features-scheduled-jobs">
      <title>Scheduled Jobs</title>

      <para>
        TorqueBox also has built-in support for scheduled jobs (like
        Cron or Windows Scheduler) but in a cross-platform way. To see
        how scheduled jobs work, let's create a job that logs the
        number of posts in our database every 10 seconds. To do this
        create a <classname>PostCounter</classname> class in the
        <filename>app/jobs</filename> directory created for us by the
        TorqueBox Rails template earlier.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/jobs/post_counter.rb</filename></title>
          <programlisting><![CDATA[class PostCounter

  def run
    puts "#{Post.count} posts in the database"
  end

end]]></programlisting>
        </example>

        We also have to tell TorqueBox about this new job and when to
        run it. To do that, edit the
        <filename>config/torquebox.yml</filename> created for us by
        the TorqueBox Rails template to have the contents below.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/config/torquebox.yml</filename></title>
          <programlisting>---
# This is the TorqueBox configuration file. Refer to the TorqueBox
# documentation at http://torquebox.org/documentation/current/ 
# for all configuration options.
web:
  context: "/"
jobs:
  post_counter:
    job: PostCounter
    cron: "*/10 * * * * ?"</programlisting>
        </example>

        Since we had to make a change to
        <filename>config/torquebox.yml</filename>, we need to restart
        TorqueBox for the job to start running. After restarting
        TorqueBox you should see output like below every 10 seconds.

        <screen>09:45:30,029 INFO  [stdout] (JobScheduler$rails_example-knob.yml_Worker-2) 2 posts in the database</screen>
      </para>
    </section>

    <section id="features-services">
      <title>Long-Running Services</title>

      <para>
        TorqueBox supports the notion of long-running services that
        get started when the application is deployed and stopped when
        the application is undeployed. This could be useful to connect
        a client to a streaming API service (like that provided by
        some social networks), monitor a resource for changes and take
        some action, or many other things. As an example, we'll create
        a service that pretends to connect to a social network and
        submit post ideas to a queue for later processing.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/services/post_idea_grabber.rb</filename></title>
          <programlisting><![CDATA[class PostIdeaGrabber

  def initialize(options)
    @queue = TorqueBox::Messaging::Queue.new(options['queue_name'])
  end

  def start
    puts "******** Starting PostIdeaGrabber ********"
    Thread.new do
      until @done
        @queue.publish("Random idea #{rand(100)}")
        sleep 2
      end
    end
  end

  def stop
    @done = true
  end
end]]></programlisting>
        </example>

        Just like with our scheduled job, we need to tell TorqueBox
        about this new service and the message queue it uses.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/config/torquebox.yml</filename></title>
          <programlisting>---
# This is the TorqueBox configuration file. Refer to the TorqueBox
# documentation at http://torquebox.org/documentation/current/ 
# for all configuration options.
web:
  context: "/"
jobs:
  post_counter:
    job: PostCounter
    cron: "*/10 * * * * ?"
services:
  post_idea_grabber:
    service: PostIdeaGrabber
    config:
      queue_name: "/queue/post_ideas"
queues:
  /queue/post_ideas:
    durable: false</programlisting>
        </example>

        Restart TorqueBox and you should see the service starting in
        the logs.

        <screen>10:43:56,316 INFO  [org.torquebox.core.runtime] (MSC service thread 1-7) Created ruby runtime (ruby_version: RUBY1_8, compile_mode: JIT, app: rails_example, context: services) in 17.73s
10:43:56,325 INFO  [stdout] (MSC service thread 1-5) ******** Starting PostIdeaGrabber ********</screen>
      </para>
    </section>

    <section id="features-processors">
      <title>Message Processors</title>

      <para>
        We have a long-running service placing messages on a queue but
        now we need something to consume those messages and do
        something with them. TorqueBox has a feature designed
        specifically for this purpose - message processors. We'll
        create a message processor to randomly choose some of the
        ideas and create new posts from them.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/processors/post_idea_processor.rb</filename></title>
          <programlisting><![CDATA[class PostIdeaProcessor < TorqueBox::Messaging::MessageProcessor

  def on_message(message)
    if (rand(10) > 8)
      puts "Creating new post from idea #{message}"
      Post.create(:title => message, :body => "Random post created from an idea")
    end
  end

end]]></programlisting>
        </example>

        As usual we need to edit
        <filename>config/torquebox.yml</filename> so TorqueBox knows
        how to wire up this new message processor.

        <example>
          <title><filename>~/torquebox_examples/rails_example/app/config/torquebox.yml</filename></title>
          <programlisting>---
# This is the TorqueBox configuration file. Refer to the TorqueBox
# documentation at http://torquebox.org/documentation/current/ 
# for all configuration options.
web:
  context: "/"
jobs:
  post_counter:
    job: PostCounter
    cron: "*/10 * * * * ?"
services:
  post_idea_grabber:
    service: PostIdeaGrabber
    config:
      queue_name: "/queue/post_ideas"
queues:
  /queue/post_ideas:
    durable: false
messaging:
  /queue/post_ideas: PostIdeaProcessor</programlisting>
        </example>

        Restart TorqueBox and you should see new posts being created
        from the random ideas.

        <screen>11:10:31,891 INFO  [stdout] (Thread-2 (HornetQ-client-global-threads-9512807)) Creating new post from idea Random idea 66</screen>
      </para>

      <para>
        Congratulations! You now have an application that uses many of
        the features of TorqueBox. For detailed documentation on
        TorqueBox, look for the User Manual in the same location you
        found this Getting Started Guide.
      </para>
    </section>
  </chapter>

  <chapter id="poorsmatic">
    <title>Poorsmatic</title>

    <para>
      This chapter shows you how to build a simple web application based
      on <ulink url="http://sinatrarb.com">Sinatra</ulink>. Althought the
      application itself is very small, it uses many TorqueBox features.
    </para>

    <para>
      We will create an application called Poorsmatic, a "poor man's
      Prismatic". This is a truly awful content discovery service that merely
      returns URL's from Twitter that contain at least one occurrence
      of the search term used to find the tweets containing the URL's
      in the first place.
    </para>

    <para>
      If you don't get it - don't worry - everything will be clear once we start
      creating it.
    </para>

    <note>
      <title>Source code</title>
      <para>
        Remember, you can see the full <ulink url="https://github.com/torquebox/examples/poorsmatic/">source code in our repository</ulink> at any time.
      </para>
    </note>

    <section id="poorsmatic-overview">
      <title>Poorsmatic application overview</title>

      <para>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="images/poorsmatic-overview.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </para>

      <para>
        The main goal of the application is to grab tweets from Twitter stream. We'll use a
        <code>TwitterService</code> implemented as TorqueBox service. The service itself will be instructed
        in which keywords we're interested via terms topic. Received tweets will be scanned for URL's
        and those URL's will be put into url's queue for processing. The <code>URLScraper</code>
        will be responsible for visiting all URL's from the urls queue and counting the words
        found in the <code>&lt;body/&gt;</code> tag on the page. Results will be put into
        database. There will be also a web interface for viewing the URL's and editing the terms.
      </para>

      <section>
        <title>Web</title>

        <para>
          We use use Sinatra web framework for this application. This is a very simple DSL framework
          for writing web applications fast, which is a perfect choice in our case.
        </para>

        <para>
          If you're new to Sinatra, the <ulink url="http://www.sinatrarb.com/">project homepage</ulink> is
          a great resource to start. It has a lot of examples and pretty good documentation.
        </para>
      </section>

      <section>
        <title>Database</title>

        <para>
          We choose <ulink url="http://www.postgresql.org/">PostgreSQL</ulink> mainly because it has
          support for transactions which will be used in our application.
        </para>
      </section>

      <section>
        <title>Configuration</title>

        <section>
          <title>Database preparation</title>

          <para>
            First please create a new user and database for the application.

            <screen><prompt>$</prompt><command>su postgres -c psql</command>
psql (9.2.2)
Type "help" for help.

<prompt>postgres=#</prompt><command>CREATE USER poorsmatic WITH PASSWORD 'poorsmatic';</command>
CREATE ROLE
<prompt>postgres=#</prompt><command>CREATE DATABASE poorsmatic;</command>
CREATE DATABASE
<prompt>postgres=#</prompt><command>GRANT ALL PRIVILEGES ON DATABASE poorsmatic to poorsmatic;</command>
GRANT
<prompt>postgres=#</prompt><command>\q</command>
            </screen>
          </para>
        </section>

        <section>
          <title>Database authentication</title>

          <para>
            To connect to the database we need to use the <code>md5</code> authentication method
            instead of <code>ident</code>. To change it please open <filename>/var/lib/pgsql/data/pg_hba.conf</filename>
            (location in <ulink url="http://fedoraproject.org">Fedora</ulink> operating system, may be different
            if you use some other OS) file and make sure you use <code>md5</code> method.
          </para>
        </section>

        <section>
          <title>Enable transactions in database</title>

          <para>
            To be able to use TorqueBox transactions in <filename>/var/lib/pgsql/data/postgresql.conf</filename> please set
            <code>max_prepared_transactions</code> to value greater than <code>0</code>. In our case <code>10</code> should
            be sufficient.
          </para>
        </section>

        <section>
          <title>ORM</title>

          <para>
            The object-relational mapper of our choice is <ulink url="http://datamapper.org/">DataMapper</ulink>.
            To see the configuration details please look at <filename>~/poorsmatic/torquebox_init.rb</filename>.
            Models are defined in the <filename>~/poorsmatic/models/</filename> directory.
          </para>

          <para>
            Although in this quick overview of the app we will not discuss the database access and ORM you can always see the
            full code in the repository.
          </para>
        </section>
      </section>
    </section>

    <section id="poorsmatic-empty">
      <title>Empty application</title>

      <para>
         To start small, let's create a minimalistic Sinatra application
         skeleton first.
      </para>

      <example>
        <title><filename>~/poorsmatic/poorsmatic.rb</filename></title>
        <programlisting><![CDATA[require 'sinatra'

class Poorsmatic < Sinatra::Base
  get '/' do
    "Hello from Poorsmatic!"
  end
end]]></programlisting>
      </example> 

      <para>
        Since Sinatra is a <ulink url="http://rack.github.com/">Rack</ulink> framework,
        we need to create a simple <filename>config.ru</filename> file which will
        inform TorqueBox that this application is a web application.

        <example>
          <title><filename>~/poorsmatic/config.ru</filename></title>
          <programlisting><![CDATA[require 'sinatra'
require 'poorsmatic'

run Poorsmatic]]></programlisting>
        </example>
      </para>

      <para>
        It's time to launch the application for the first time. First we need to
        start TorqueBox by executing <command>torquebox run</command> command. The output
        should be similar to this:

        <screen><prompt>$</prompt><command>torquebox run</command>
...
14:34:42,734 INFO  [org.torquebox.jobs.as] Initializing TorqueBox Jobs Subsystem
14:34:42,735 INFO  [org.torquebox.services.as] Initializing TorqueBox Services Subsystem
14:34:42,738 INFO  [org.torquebox.core.as] Initializing TorqueBox Core Subsystem
14:34:42,740 INFO  [org.torquebox.security.as] Initializing TorqueBox Auth Subsystem
14:34:42,740 INFO  [org.torquebox.web.as] Initializing TorqueBox Web Subsystem
14:34:42,733 INFO  [org.torquebox.cdi.as] Initializing TorqueBox CDI Subsystem
14:34:42,792 INFO  [org.torquebox.stomp.as] Initializing TorqueBox STOMP Subsystem
14:34:42,791 INFO  [org.projectodd.polyglot.stomp.as] Initializing Polyglot STOMP Subsystem
14:34:42,807 INFO  [org.projectodd.polyglot.hasingleton.as] Initializing HA-Singleton Subsystem
14:34:42,808 INFO  [org.projectodd.polyglot.cache.as] Initializing Polyglot Cache Subsystem
14:34:42,854 INFO  [org.torquebox.core.as] Welcome to TorqueBox AS - http://torquebox.org/
14:34:42,855 INFO  [org.torquebox.core.as]   version........... 2.2.0
14:34:42,856 INFO  [org.torquebox.core.as]   build............. 74
14:34:42,857 INFO  [org.torquebox.core.as]   revision.......... 530d7d30a5ba5ca953eba21b2aa6df1bf4022649
...
14:35:02,072 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015961: Http management interface listening on http://127.0.0.1:9990/management
14:35:02,073 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015951: Admin console listening on http://127.0.0.1:9990
14:35:02,073 INFO  [org.jboss.as] (Controller Boot Thread) JBAS015874: JBoss AS 7.1.x.incremental.129 "Arges" started in 21875ms - Started 281 of 400 services (118 services are passive or on-demand)</screen>

        Now we're ready to deploy the application. To do so execute the <command>torquebox deploy</command> command in the <filename>~/poorsmatic</filename> directory:

        <screen><prompt>$</prompt><command>torquebox deploy</command>
Deployed: poorsmatic-knob.yml
    into: /home/goldmann/work/torquebox-2.2.0/jboss/standalone/deployments</screen>

        You can now reach your application on <ulink url="http://localhost:8080/"/>. If you see
        "Hello from Poorsmatic!" message it means that everything worked perfectly!
      </para>

      <para>
        Congratulations! You have now a working web application. In the next steps
        we will extend the functionality of the app and use some of the TorqueBox
        features.
      </para>

      <para>
        It's a good idea to use <ulink url="http://gembundler.com/">Bundler</ulink> at this point.
        This will help us use the required versions of librarires in the future.

        <example>
          <title><filename>~/poorsmatic/Gemfile</filename></title>
          <programlisting><![CDATA[source "http://rubygems.org"

gem "torquebox", "2.2.0"
gem "sinatra", "1.3.3"
]]></programlisting>
        </example>

        Every time you change the <filename>Gemfile</filename> file please run <command>bundle install</command>
        to make sure the required software will be installed. A file called
        <filename>Gemfile.lock</filename> will be created.

        <screen><prompt>$</prompt><command>bundle install</command>
...
Using torquebox (2.2.0) 
Using sinatra (1.3.3) 
Using bundler (1.2.3) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.</screen>

        Now let's bite in some real TorqueBox meat.
      </para>

    </section>

    <section id="poorsmatic-basic">
      <title>Basic TorqueBox features</title>

      <para>
        Since we have the skeleton application, let's add the basic TorqueBox features.
      </para>

      <section>
        <title>Deployment descriptor</title>

        <para>
          Before we start adding new features we need to add first a deployment descriptor
          to our application. There are two types of deployment descriptors: internal and external.
          Additionally you have the choice of using pure Ruby DSL or specify the options in YAML format.
          In our case we'll use Ruby DSL syntax. Please refer to TorqueBox manual if you want
          to read more about deployment descriptors.
        </para>

        <para>
          TorqueBox did pretty job at guessing what kind of application is the
          one we just deployed. Since it's a web application, TorqueBox automatically
          registered this application at root context (the default). We can change
          this (and many other things) by using a deployment descriptor.
    
          <example>
            <title><filename>~/poorsmatic/torquebox.rb</filename></title>
            <programlisting><![CDATA[TorqueBox.configure do
  web do
    context "/poorsmatic"
  end
end]]></programlisting>
          </example> 

          If you redeploy now your application by using the <command>torquebox deploy</command>
          command you'll see that your application is no longer available under the
          <ulink url="http://localhost:8080/">root context</ulink> but it's reachable
          under new <ulink url="http://localhost:8080/poorsmatic/">poorsmatic context</ulink>.
          Please note the change of the context in the TorqueBox log files:

        <screen>...
13:25:10,415 INFO  [org.torquebox.core.runtime] (MSC service thread 1-3) Created ruby runtime (ruby_version: RUBY1_9, compile_mode: JIT, app: poorsmatic, context: web) in 2.32s
13:25:10,430 INFO  [org.jboss.web] (MSC service thread 1-2) JBAS018210: Registering web context: /poorsmatic
13:25:10,478 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018565: Replaced deployment "poorsmatic-knob.yml" with deployment "poorsmatic-knob.yml"</screen>

        </para>

      </section>

      <section>
        <title>Service</title>

        <para>
          In our application we will use Twitter to receive tweets from the stream filtered by
          some keywords. The best way to run something constantly is to implement it as a TorqueBox
          service. Let's start with a skeleton.

          <example>
            <title><filename>~/poorsmatic/twitter_service.rb</filename></title>
            <programlisting><![CDATA[class TwitterService
  def initialize(credentials = {})
  end

  def start
  end

  def stop
  end
end]]></programlisting>
          </example>

          The code is pretty self-explaining. The only thing you need to keep in mind is
          that the <code>start</code> method is executed when you deploy the service. Similarly
          the <code>stop</code> method is executed when you undeploy the service. As simple as that.
        </para>

        <para>
          Currently the service does literally nothing. We need to use a Twitter client. In our
          example we'll use the <ulink url="https://github.com/tobias/twitter4j4r">twitter4j4r</ulink>
          client. Please don't ask about the name...

          <example>
            <title><filename>~/poorsmatic/twitter_service.rb</filename></title>
            <programlisting><![CDATA[require 'twitter4j4r'

class TwitterService
  def initialize(credentials = {})
    @terms = []

    @client = Twitter4j4r::Client.new(
        :consumer_key     => credentials['consumer_key'],
        :consumer_secret  => credentials['consumer_secret'],
        :access_token     => credentials['access_token'],
        :access_secret    => credentials['access_secret']
    )

    @client.on_exception do |exception|
      puts "An error occured while reading the stream: #{exception.message}"
    end
  end

  def start
    @client.track(*@terms) do |status, client|
    end
  end

  def stop
    @client.stop
  end
end]]></programlisting>
          </example>

          Now we need to inform TorqueBox that we want to deploy a service
          implemented in <code>TwitterService</code> class. We need to do it in the
          mentioned before <filename>torquebox.rb</filename> deployment descriptor.
          You may also ask how do we inject the credentials required to connect to Twitter?
          Yes, you're right, deployment descriptor.

          <example>
            <title><filename>~/poorsmatic/torquebox.rb</filename></title>
            <programlisting><![CDATA[TorqueBox.configure do
  ...
  service TwitterService do
    name 'twitter-service'
    config do
      consumer_key 'Consumer key'
      consumer_secret 'Consumer secret'
      access_token 'Access token'
      access_secret 'Access token secret'
    end
  end
end]]></programlisting>
          </example>

          Before you deploy the application make sure you use correct credentials. You can
          generate them on the <ulink url="https://dev.twitter.com/apps">Twitter apps</ulink>
          page. Just create new application and you're ready to rock.
        </para>

        <para>
          You may wonder how do we update the keyword list we want to watch on Twitter?
          We'll use messaging features of TorqueBox.
        </para>

      </section>

      <section>
        <title>Messaging</title>

        <para>
          Messaging allows us to create loosely coupled applications. Using queues and topics
          aswell as message producers and consumers is very easy, so let's start right away!
          If you're new to the messaging terms, don't fear - take a look at the messaging
          section of TorqueBox manual.
        </para>

        <section>
          <title>Queue and topic deployment</title>

          <para>
            We need to create one queue and a topic. We'll use the topic to send/receive keywords
            we want to watch on Twitter and the queue will be used to send urls from tweets
            containing one or more specified keywords. Creating them is very simple, we just need
            to add the queue and topic constructs to the deployment descriptor.

            <example>
              <title><filename>~/poorsmatic/torquebox.rb</filename></title>
              <programlisting><![CDATA[TorqueBox.configure do
  ...
  queue '/queues/urls'
  topic '/topics/terms'
end]]></programlisting>
            </example>

            That's everything required to deploy a queue and topic with your application.
            Both will be started when you deploy the application and stopped when you
            undeploy it. Handy feature, isn't?
          </para>

        </section>

        <section>
          <title>Message consumers</title>

          <para>
            It's pretty easy to consume a message from a queue or topic. You can use message
            processors.

            <example>
              <title><filename>~/poorsmatic/term_consumer.rb</filename></title>
              <programlisting><![CDATA[class TermConsumer < TorqueBox::Messaging::MessageProcessor
  def on_message(message)
    # do stuff here
  end
end]]></programlisting>
            </example>

            A new message processor will be created for each message that arrives to the queue.
            The message itself will be injected to the <code>on_message</code> method.
            You can do whatever you want with it afterwards. In our case we want to update the
            keywords in the twitter service. The easiest thing to do is to simply get access to the
            service and execute an update method on it. Let's do it!

            <example>
              <title><filename>~/poorsmatic/term_consumer.rb</filename></title>
              <programlisting><![CDATA[class TermConsumer < TorqueBox::Messaging::MessageProcessor
  include TorqueBox::Injectors

  def initialize
    @twitter_service = fetch('service:twitter-service')
  end

  def on_message(terms)
    @twitter_service.update(terms)
  end
end]]></programlisting>
            </example>

            When the message processor will be created TorqueBox will use its power to inject the
            service into the consumer. Afterwards the terms will be injected into the <code>on_message</code>
            method and we'll execute the <code>update</code> method on the service itself. The only thing
            that left now is to implement the <code>update</code> method in <code>TwitterService</code> class.

            <example>
              <title><filename>~/poorsmatic/twitter_service.rb</filename></title>
              <programlisting><![CDATA[class TwitterService
  def initialize(credentials = {})
    @terms = []
    ...
  end

  def update(terms)
    @terms = terms

    stop
    start
  end
  ...
end]]></programlisting>
            </example>

            Execution of this method will update the terms list. Additionally the Twitter client
            will be restarted to watch new keywords.
          </para>

          <para>
            You can find another message processor used to retrieve and parse web pages in 
            <filename>~/poorsmatic/url_scrapper.rb</filename> file. Since <code>URLScrapper</code>
            doesn't do anything fancy besides counting the words in <code>&lt;body&gt;</code> and
            saving the result in a database we'll not go into discussing it this time, sorry.
          </para>
        </section>

        <section>
          <title>Producing messages</title>

          <para>
            You know now how to receive messages from topics (or queues), but the remaining question is
            how to put new messages into the queue? We'll look at it in this section.
          </para>

          <para>
            The <code>TwitterService</code> besides retrieving tweets for particular keywords is also
            supposed to pull out every link from the received tweets. These links will be put into a queue
            for later processing.
          </para>

          <para>
            We will use the twitter-text gem to retrieve the link, but you're free to do it on your own using
            regular expressions for example.

            <example>
              <title><filename>~/poorsmatic/twitter_service.rb</filename></title>
              <programlisting><![CDATA[require 'twitter-text'

class TwitterService
  include TorqueBox::Injectors
  ...
  def start
    @client.track(*@terms) do |status, client|
      urls = extract_urls(status.text)

      unless urls.empty?
        queue = fetch('/queues/urls')

        urls.each do |url|
          queue.publish(url)
        end
      end
    end
  end
  ...
end]]></programlisting>
            </example>

            For each received tweet we try to find an URL in it.
            If we find at least one, we send this URL as a string to the queue. To do this
            we inject first the queue and later we execute the <code>publish</code> method
            on it. Easy.

          </para>
        </section>

      </section>

      <section>
        <title>Transactions</title>

        <para>
          The last feature of TorqueBox used in the presented application are distributed transactions.
          Distributed transaction ensure the atomicity of the execution. They can span across the whole
          application. For example a transaction could be started in the web layer and end in database.
          This is exactly how we use it in Poorsmatic!

          <example>
            <title><filename>~/poorsmatic/poorsmatic.rb</filename></title>
            <programlisting><![CDATA[require 'torquebox'
require 'sinatra'
require 'haml'
require 'models/term'

class Poorsmatic < Sinatra::Base
  include TorqueBox::Injectors
  ...
  helpers do
    def terms_changed
      terms = []

      Term.all.each {|t| terms << t.term}

      topic = fetch('/topics/terms')

      topic.publish(terms)
    end
  end
  ...
  post '/terms' do

    term = Term.new(:term => params[:term])

    TorqueBox.transaction do
      if term.save
        terms_changed
      else
        session[:errors] = []
        term.errors.each {|e| session[:errors] << e.first }
      end
    end

    redirect to('/terms')
  end

  delete '/term/:id' do
    TorqueBox.transaction do
      Term.get(params[:id]).destroy
      terms_changed
    end

    redirect to('/terms')
  end
  ...
end]]></programlisting>
          </example>

          Look at the <code>post '/terms'</code> block. This code is executed when we try to save a new
          term using the web page. First - we create a <code>Term</code> object, then we start
          a transaction and try to save the object to the database. If the operation was
          successfull we send a list of the terms (see <code>terms_changed</code> method)
          as array to the <code>/topic/terms</code> topic.
        </para>

        <para>
          The nice thing about transaction is that they're atomic. This means that if an error occurs
          in the transaction block, the transaction is rolled back and the state is restored. For
          example if an error occurs in our case during sending a message to the topic, the whole
          transaction is rolled back and the database state will be restored too!
        </para>

        <para>
          You can find another usage of transaction in the <code>delete '/term:id'</code> block.
          It'll make sure that we'll notify the terms queue only after successful removal of the term
          from database.
        </para>

        <para>
          Since distributed transactions is an advanced topic you can read about them in the TorqueBox manual.
          You'll find there more information about transactions itself or configuration options.
        </para>

      </section>

    </section>
    <section>
      <title>Wrapping up</title>

      <para>
        Congratulations! You know now many of TorqueBox features. There are still many to explore.
        To learn more about them just open the TorqueBox manual and use them.
      </para>

      <para>
        Poorsmatic application was just a simple example. You can always go back to the
        <ulink url="https://github.com/torquebox/examples/poorsmatic/">source code</ulink>
        and see again how it was done.
      </para>
    </section>

  </chapter>

</book>
